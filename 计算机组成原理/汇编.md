# 汇编

16位通用寄存器：`AX、BX、CX、DX`

通用寄存器都可以分为两个8位寄存器来使用`AH、AL...`

字节：byte 8个bit组成，可以存在8位寄存器中

字：word 2个字节组成



```assembly
mov ax,18 //讲18移入ax
add ax,bx	//将ax与bx相加存入ax
```



#### 给出物理地址方法

将两个16位的地址合成一个20位地址

将**段地址和偏移地址**送入地址加法器

**物理地址=段地址*16+偏移地址1**



#### 段寄存器

`CS、DS、SS、ES`



#### 偏移地址寄存器

**BX, SP, SI, DI **

BP和SP寄存器称为指针寄存器，与SS联用，为访问现行堆栈段提供方便。通常BP寄存器在间接寻址中使用，操作数在堆栈段中，由SS段寄存器与BP组合形成操作数地址即BP中存放现行堆栈段中一个数据区的“基址”的偏移量，所以称BP寄存器为基址指针。

寄存器SI和DI称为变址寄存器，通常与DS一起使用，为访问现行数据段提供段内地址偏移量。在串指令中，其中源操作数的偏移量存放在SⅠ中，目的操作数的偏移量存放在DI中，SI和DI的作用不能互换，否则传送地址相反。在串指令中，SI、DI均为隐含寻址，此时，SI和DS联用，Dl和ES联用。



#### CS和IP

最关键的寄存器，指示了CPU当前要读取的指令的地址

8086中，任意时刻，CPU将CS:IP指向的内容当作指令执行



8086中的大部分寄存器都可以通过`mov`指令修改，但是`CS IP`不可以通过mov改变

如果想要修改CS、IP的内容，可以使用`jmp 段地址:偏移地址`实现

如果只想修改IP，可以使用`jmp 某一合法容器` 比如`jmp ax`



#### DS和[address]

将内存中的数据存到寄存器中

可以使用

```assembly
mov AX,2000H
mov ds,ax
mov al,[0]
```



#### 栈

```assembly
pop ax
push ax //以字为单位
```

**任意时刻，SS:SP指向栈顶元素**



inc ax 让ax增加1

#### assume

将段寄存器和段代码链接



#### 循环指令

##### loop

循环函数，具体代码`loop s`

1. cx=cx-1
2. 如果cx==0向下执行，cx!=0返回到s

汇编语言中数字不能用字母开头



##### `loopnz`

循环条件CX!=0,ZF=0

##### `loopz`

循环条件CX!=0,ZF=1



dw 数据可以在内存中定义数据

```assembly
start
end start 指明程序开始的地方
mov ax,4cooh
int 21h
```



#### 多个段的程序

`assume`只是将有联系的段地址和段链接起来，但是并没有在cpu中联系，所以还需要对段寄存器赋值



#### and和or

and与指令 按位进行与运算

or或指令 按位进行或运算



[bx+idata]意思是偏移地址是(bx)+idata



#### div除法



#### 数据段定义

dd定义双字型数

dup是定义重复字节

定义200次0：

```assembly
db 200 dup(0) 
```



#### 转移指令原理

转移行为：

- 只修改IP
- 同时修改IP和CS

转移指令的分类

offset 偏移地址





```assembly
jmp short 标号
```



​	next DB 10,13,'$'换行符和回车



#### 标志寄存器





#### JE和JNE

JE:相等跳转

JNE:不相等跳转



```assembly
ja

jb

rep movesb
```



#### CBW，CWD

1. 字节扩展指令格式：CBW （隐含的操作数为AL）
执行的操作 ：
当AL的最高位为0时（D7=0）——>AH=00H
当AL的最高位为1时（D7=1）——>AH=FFH

2. 字扩展指令格式： CWD （隐含的操作数为AX）
执行的操作 ：
当AX的最高位为0时（D15=0）——>DX=0000H
当AX的最高位为1时（D15=1）——>DX=FFFFH

#### NEG

求补



#### NOT 求反



#### XCHG 交换



## 程序

### 以二进制输出：

左移，最高位到cf，输出cf
