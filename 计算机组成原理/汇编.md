# 汇编

16位通用寄存器：`AX、BX、CX、DX`

通用寄存器都可以分为两个8位寄存器来使用`AH、AL...`

字节：byte 8个bit组成，可以存在8位寄存器中

字：word 2个字节组成



```assembly
mov ax,18 //讲18移入ax
add ax,bx	//将ax与bx相加存入ax
```



#### 给出物理地址方法

将两个16位的地址合成一个20位地址

将**段地址和偏移地址**送入地址加法器

**物理地址=段地址*16+偏移地址1**



#### 段寄存器

`CS、DS、SS、ES`



#### CS和IP

最关键的寄存器，指示了CPU当前要读取的指令的地址

8086中，任意时刻，CPU将CS:IP指向的内容当作指令执行



8086中的大部分寄存器都可以通过`mov`指令修改，但是`CS IP`不可以通过mov改变

如果想要修改CS、IP的内容，可以使用`jmp 段地址:偏移地址`实现

如果只想修改IP，可以使用`jmp 某一合法容器` 比如`jmp ax`



#### DS和[address]

将内存中的数据存到寄存器中

可以使用

```assembly
mov AX,2000H
mov ds,ax
mov al,[0]
```



#### 栈

```assembly
pop ax
push ax //以字为单位
```

**任意时刻，SS:SP指向栈顶元素**



inc ax 让ax增加1

#### assume

将段寄存器和段代码链接



#### loop

循环函数，具体代码`loop s`

1. cx=cx-1
2. 如果cx==0向下执行，cx!=0返回到s

汇编语言中数字不能用字母开头



dw 数据可以在内存中定义数据

```assembly
start
end start 指明程序开始的地方
mov ax,4cooh
int 21h
```



#### 多个段的程序

`assume`只是将有联系的段地址和段链接起来，但是并没有在cpu中联系，所以还需要对段寄存器赋值



#### and和or

and与指令 按位进行与运算

or或指令 按位进行或运算



[bx+idata]意思是偏移地址是(bx)+idata

