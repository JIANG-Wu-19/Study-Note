# 算法分析与设计

## 序言

时间复杂度：用算法的**基本操作（算法中最重要的操作）**的执行次数来度量算法的时间效率
$$
T(n) ≈ copC(n)
$$
**一个需要指数级操作次数的算法只能用来解决规模非常小的问题**



### 渐进符号

**f(n)<=Cg(n)**，记作t(n)=O(g(n))

f(n)≥Cg(n)，记作f(n)= **Ω**(g(n))



### 求时间复杂度的方法

#### 递归树

<img src="pics/image-20230611083445191-16864436874611.png" alt="image-20230611083445191" style="zoom: 67%;" />



#### 主定理

$$
T(n)=aT(n/b)+n^d && a>=1,b>=1 \\
T(n)=  \left\{ \begin{matrix} O(n^{log_b^a})&ifa>b^d \\ O(n^dlog_bn) & ifa=b^d \\
O(n^d) & ifa<b^d
\end{matrix} \right.
$$



### NPC问题

P问题：有多项式解

NP问题：指那些可以在多项式时间内被验证的问题。换句话说，如果一个解被提供给你，你可以在多项式时间内验证它是否是正确的。然而，尚未找到一种有效的算法来在多项式时间内解决所有的NP问题。例子：背包问题，旅行商问题

NPC问题：

NPC问题是指NP完全（NP-Complete）问题，是一类特殊的NP问题。一个问题被称为NP完全，如果它既属于NP问题集合，又具有一个特殊的性质：任何一个NP问题都可以在多项式时间内约约归（polynomial-time reduce）到该问题。

NP难问题：NP难问题（NP-Hard）和NP完全问题（NPC，NP-Complete）是两个相关但不完全相同的概念。

<img src="https://pic2.zhimg.com/80/v2-1a4f4cfd668c28c1b47c266c7fe85199_720w.webp" alt="img" style="zoom: 150%;" />

## 递归

思想和栈比较相同，我们需要找到循环终止的条件

步骤：

1. 明白函数想干嘛
2. 寻找函数终止条件
3. 找出函数的等价关系时



时间复杂度分析：

- 决定用哪个参数作为输入规模的度量
- 找出算法的基本操作
- 检查对相同规模的输入，基本操作的执行次数是否相同，如果不同，必须对最差、平均及最优效率单独研究
- 建立一个递推关系式及相应的初始条件
- 求解这个递归关系式，或者至少确定解的增长次数

**递归的简洁性可能会掩饰其算法的效率复杂性**



## 分治

**分治法的几个步骤：**

1、将原始问题划分为k个相同类型的子问题。（问题：为什么？）

2、子问题不可解还可继续划分。（问题：分到什么时候结束？）

3、求解每个子问题。

4、将每个最小子问题的解合并成原问题的解。



**分治法适用条件：**

1、原始可分解，且分解出来的子问题和原始问题就有相同的类型。

2、分解出来的子问题到很小时可以很容易（在很短的时间和空间内能求解）求解。

3、**子问题的解能合并。**（这是能否使用分治算法的关键）





### 归并排序

归并排序的时间复杂度任何情况下都是 O(nlogn)

空间复杂度是是指在某个时刻最大的空间数量，为n个



### 分治矩阵乘法

c++步骤：

1. 声明类
2. 主要递归函数：如果矩阵的长度大于2，则继续分割
3. 辅助函数：矩阵分割，矩阵合并，矩阵相加，2阶矩阵相乘



### 棋盘覆盖问题

函数变量：tr tc左上角点，dr dc当前分治中特殊点，size长度

如果宽度等于2，就覆盖除了特殊点的其他点

如果宽度不等于2，就对区域四分
$$
T(n)=O(4^k)
$$


### 寻找第k小数





### 求二维图中最近的两个点

按x升序排列，对半分 最小值等于（左边最小，右边最小，一个在左一个在右中最小）

当分到只剩两个时，直接返回距离



### 快速傅里叶变化（FFT）

$$
P(x):[p_0,p_1,...,p_{n-1}] \\
w=e^{\frac{2\pi i}{n}}:[w^0,w^1,...,w^{n-1}]
$$

将w带入p(x)求解

可以对整个FFT公式左右分治

左侧：
$$ {FFT}
P_e(x):[p_0,p_2,...,p_{n-2}] \\
w=e^{\frac{2\pi i}{n}}:[w^0,w^1,...,w^{n-1}]
$$

右侧：
$$
P_o(x):[p_1,p_3,...,p_{n-1}] \\
w=e^{\frac{2\pi i}{n}}:[w^0,w^1,...,w^{n-1}]
$$

![微信图片_20230427084257](pics/微信图片_20230427084257.jpg)



## 动态规划

### 求二项式系数

利用二维数组存储n从1开始的对角线数组，$$dp[i][k]=dp[i-1][k]+dp[j-1][k-1]$$



### 拓扑图中最长距离

依次遍历入度为0的点，判断当前节点大小：
$$
dis[i]=max{dis[i],dis[j]+dis(i,j)}
$$


### 加空格编辑距离

编辑距离：将一个字符串变成另一个字符串的最小改变数量

对应有两种情况：
$$
x[i]==y[j]时，&E[i][j]=E[i-1][j-1]\\
x[i]!=y[j]时，&E[i][j]=min(E[i-1][j],E[i][j-1],E[i-1][j-1])+1
$$


### 背包问题

#### 01背包

定义变量`bp[i][j]: 将前i件物品装进限重为j的背包可以获得的最大价值`

```pseudocode
function 01package(w[1...n],v[1...n]){
	for i=1 to n do
		for j=1 to n do
			dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+v[i];
	return dp[n][n];
}
```



#### 完全背包

与01背包问题只有一个不同地方：

状态量的定义应该改为：`dp[i][j] = max(dp[i-1][j],dp[i][j-w[i]]+v[i];`

这样就是说可以在选择每个物体的时候，还可以选择要装入几个物体



#### 多重背包

状态方程：

```c
# k为装入第i种物品的件数, k <= min(n[i], j/w[i])
dp[i][j] = max{(dp[i-1][j − k*w[i]] + k*v[i]) for every k}
```





### 链式矩阵相乘

求解矩阵链相乘问题时动态规划算法的另一个例子。给定一个n个矩阵的序列（矩阵链）<A1,A2,...,An>，我们希望计算它们的乘积  A1A2...An

例如如果有矩阵链为<A1,A2,A3,A4>,则共有5种完全括号化的矩阵乘积链。

(A1(A2(A3A4)))、(A1((A2A3)A4))、((A1A2)(A3A4))、((A1(A2A3))A4)、((A1(A2A3))A4) 对矩阵链加括号的方式会对乘积运算的代价产生巨大影响。

 因此，A(i)A(i+1)...A(j)的最小代价括号化方案的递归求解公式变为：
    ①如果i=j，m[i,j]=0
    ②如果i<j，m[i,j]=min{m[i,k]+m[k+1,j]+p(i-1)p(k)p(j)}  i<=k<j

```pseudocode
function MATRIX_CHAIN_ORDER(P(0...n),i,j):
	if i==j then:
		m[i][j] := 0;
	if i<j then:
		for x := i to j
			left := MATRIX_CHAIN_ORDER(P(0...n),i,x)
			right := MATRIX_CHAIN_ORDER(P(0...n),x+1,j)
			m[i][j] = min(left+right+P(i-1)P(k)P(j),m[i][j]);
	return m[i][j];
```



### 全源最短路径问题

```pseudocode
For i=1 to n do:
	for j=1 to n do
		dij(0)= ∞;
For all (i,j) ∈E do 
		dij(0)=w(i, j);
For k=1 to n do: 
		for i=1 to n do:
      		for j=1 to n do
      			dij(k) = min{dij(k-1) , dik(k-1) + dkj(k-1)}
return D(n);
```



### 货担郎问题



## DFS BFS

### DFS

#### 递归

```pseudocode
function dfs(n){
	if n==node: 
		return n;
	for nb in n.邻居:
		if !nb.ischecked:
			nb.ischecked = True
			return dfs(nb);
}
```



#### 非递归

```pseudocode
function dfs(n){
	var s:stack
	s.push(n)
	while not s.empty:
		node = s.pop()
		for nb in n.邻居:
			if !nb.ischecked:
				if nb = node:
					return nb;
				nb.ischecked = True
				dfs(nb);
}
```



#### dfs判断是否有圈





#### dfs拓扑排序





#### dfs找到所有强连通块





## 贪心

Prim算法

时间复杂度：vloge

### 最小生成树

#### Prim算法

注意并查集的合并

每次选择图中最小的遍，如果不构成环就继续

```pseudocode
function prim(G(V,E)):
	for i:=0 to V.size:
		p[i]=i;
	sort(E) #按照E的大小排序
	for e in E:
		n = Find(p, e.begin)
		m = Find(p, e.end)
		if n!=m:
			p[e.end] = n;
		ans.add(e);
	return ans;

function find(p,v){
	n = p[v]
	while(n!=p[n]){
		n=p[n];
	}
	return n;
}
```



#### Kruskal算法

```pseudocode
function kruskal(G(V,E),v):
	isSelected[V.size]
	connections.add(V.edges)
	sort(connections);
	for e in connections:
		if !isSelected[e.end]:
			mst+=e.value
			isSelected[e.end] = True;
    }
    return mst;
```



#### Dijkstra算法



```pseudocode
function kruskal(G(V,E),v):
	for i:=0 to V.size();
		notfind.add(V[i](无穷))
		isSelected[i]=false;
	result = {v(0)}
	notfind.delete(v)
	for e in v.Edges:
		notfind[e.end] = e.value;
	
	while !notfind.isempty():
		p = min(notfind)
		result[p] = notfind[p];
		notfind.delete[p];
		for e in p.Edges:
			if notfind.contain(e.end):
				if e.value+result[p] < notfind[e.end]:
					notfind[e.end] = e.value+result[p];
			
	return result;
```



#### Bellman-Ford







#### SPFA







#### 田忌赛马

1. 按顺序排列
2. 田忌最快和齐王最快的马比较
   1. 比得过，就比
   2. 不能取胜
      1. 比较两人最慢的马，赢了就赢，然后继续选择下一组
      2. 没赢的话就让田忌最慢的马和齐王最快的比较



## 回溯法(BackTracking)

​		回溯法是从初始状态出发，按照深度优先搜索的方式，根据产生子结点的条件约束，搜索问题的解。当发现当前结点不满足求解条件时，就回溯，尝试其他的路径。回溯法是一种“能进则进，进不了则换，换不了则退”的搜索方法。

​		类似于一种遍历所有的解的方法，但是注意不满足条件

### 八皇后

```pseudocode
function backtrack(k){
	if k==max:
		print(ans);
	else:
		for i:=1 to max:
			for j:=1 to k:
				if ans[j] == i || abs(k-j)==abs(ans[j]-i):
					flag:=False
					break;
			if flag != False:
				ans[k]:=i
				backtrack(k+1);
}
```



## 分支界限法

目的是找出**满足约束条件的一个解**，或者是**满足约束条件的某种最优解**

分支界限法以`广度优先`或`最小耗费优先`的方法搜索解空间树

1. 以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树
2. 分支限界法中，每一个活结点只有一次机会成为扩展结点，活结点一旦成为扩展结点，就一次性产生其所有儿子结点，其中导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中
3. 然后从活结点表中取下一结点成为当前扩展结点
4. 重复上述结点扩展过程，直至到找到所需的解或活结点表为空时为止



**常见的两种分支限界法**：

1. FIFO先进先出
2. 优先队列式分支限界法

