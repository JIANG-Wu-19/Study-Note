# 汇编

## 概念

16位通用寄存器：`AX、BX、CX、DX`

通用寄存器都可以分为两个8位寄存器来使用`AH、AL...`

字节：byte 8个bit组成，可以存在8位寄存器中

字：word 2个字节组成



```assembly
mov ax,18 //讲18移入ax
add ax,bx	//将ax与bx相加存入ax
```



#### 给出物理地址方法

将两个16位的地址合成一个20位地址

将**段地址和偏移地址**送入地址加法器

**物理地址=段地址*16+偏移地址1**



#### 段寄存器

`CS、DS、SS、ES`



#### 偏移地址寄存器

**BX, SP, SI, DI **

BP和SP寄存器称为指针寄存器，与SS联用，为访问现行堆栈段提供方便。通常BP寄存器在间接寻址中使用，操作数在堆栈段中，由SS段寄存器与BP组合形成操作数地址即BP中存放现行堆栈段中一个数据区的“基址”的偏移量，所以称BP寄存器为基址指针。

寄存器SI和DI称为变址寄存器，通常与DS一起使用，为访问现行数据段提供段内地址偏移量。在串指令中，其中源操作数的偏移量存放在SⅠ中，目的操作数的偏移量存放在DI中，SI和DI的作用不能互换，否则传送地址相反。在串指令中，SI、DI均为隐含寻址，此时，SI和DS联用，Dl和ES联用。



#### CS和IP

最关键的寄存器，指示了CPU当前要读取的指令的地址

8086中，任意时刻，CPU将CS:IP指向的内容当作指令执行



8086中的大部分寄存器都可以通过`mov`指令修改，但是`CS IP`不可以通过mov改变

如果想要修改CS、IP的内容，可以使用`jmp 段地址:偏移地址`实现

如果只想修改IP，可以使用`jmp 某一合法容器` 比如`jmp ax`



#### DS和[address]

将内存中的数据存到寄存器中

可以使用

```assembly
mov AX,2000H
mov ds,ax
mov al,[0]
```



#### 栈

```assembly
pop ax
push ax //以字为单位
```

**任意时刻，SS:SP指向栈顶元素**



inc ax 让ax增加1

#### assume

将段寄存器和段代码链接



#### 循环指令

##### loop

循环函数，具体代码`loop s`

1. cx=cx-1
2. 如果cx==0向下执行，cx!=0返回到s

汇编语言中数字不能用字母开头



##### `loopnz`

循环条件CX!=0,ZF=0

##### `loopz`

循环条件CX!=0,ZF=1



dw 数据可以在内存中定义数据

```assembly
start
end start 指明程序开始的地方
mov ax,4cooh
int 21h
```



#### 多个段的程序

`assume`只是将有联系的段地址和段链接起来，但是并没有在cpu中联系，所以还需要对段寄存器赋值







[bx+idata]意思是偏移地址是(bx)+idata





#### 数据段定义

dd定义双字型数

dup是定义重复字节

定义200次0：

```assembly
db 200 dup(0) 
```



#### 转移指令原理

转移行为：

- 只修改IP
- 同时修改IP和CS

转移指令的分类

offset 偏移地址





```assembly
jmp short 标号
```



​	next DB 10,13,'$'换行符和回车



#### NEG

求补



#### NOT 求反





#### 求补

不管 按位取反 末尾加一



## 指令

### 数据传送指令

`XCHG`：交换字或字节

*`LEA`*：把地址装入



### 算数运算指令

*`CBW`* 字节转换为字。 (把AL中字节的符号扩展到AH中去)

*`CWD`* 字转换为双字。 (把AX中的字的符号扩展到DX中去)

#### CBW，CWD

1. 字节扩展指令格式：CBW （隐含的操作数为AL）
   执行的操作 ：
   当AL的最高位为0时（D7=0）——>AH=00H
   当AL的最高位为1时（D7=1）——>AH=FFH

2. 字扩展指令格式： CWD （隐含的操作数为AX）
   执行的操作 ：
   当AX的最高位为0时（D15=0）——>DX=0000H
   当AX的最高位为1时（D15=1）——>DX=FFFFH



### 逻辑运算

#### AND和OR

and与指令 按位进行与运算

or或指令 按位进行或运算



#### **XOR** 按位异或



#### TEST

`test`：Test命令将两个操作数进行逻辑与运算，并根据运算结果设置相关的标志位。但是，Test命令的两个操作数**不会**被改变。

`TEST AX,BX` 与`AND AX,BX`命令有相同效果，只是Test指令不改变AX和BX的内容，而AND指令会把结果保存到AX中。

##### 作用详细说明

将两个操作数进行按位AND,设结果是TEMP

1. SF = 将结果的最高位赋给SF标志位，例如结果最高位是1，SF就是1
2. 看TEMP是不是0，如果TEMP是0，ZF位置1；如果TEMP不是0，ZF位置0
3. PF是奇偶校验位，偶数个1的时候为1



#### 位移指令

SHL 逻辑左移。
SAL 算术左移。(=SHL)
SHR 逻辑右移。
SAR 算术右移。(=SHR)

指令 操作数,操作次数
移位一次时， 可直接用操作码。 如 SHL AX，1。
移位>1次时， 则由寄存器CL给出移位次数。
如 MOV CL，04
SHL AX，CL



ROL 循环左移。
ROR 循环右移。
RCL 通过进位的循环左移。   整体左移，最高位移入CF，CF原有位置放到最低位
RCR 通过进位的循环右移。  整体右移...
以上八种移位指令，其移位次数可达255次。



### 串指令 

`CX` 重复次数计数器. 

DF标志  0表示重复**作中SI和DI应自动增量; 1表示应自动减量. **



MOVS 串传送. 
( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) 
CMPS 串比较. 
( CMPSB 比较字符. CMPSW 比较字. )



REP 当CX>0时重复. 
REPE/REPZ         当ZF=1或比较结果相等,且CX>0时重复. 
REPNE/REPNZ   当ZF=0或比较结果不相等,且CX>0时重复. 
REPC    				当CF=1且CX>0时重复. 
REPNC 				当CF=0且CX>0时重复.



### 程序转移指令

#### 无条件转移

`JMP`：无条件转移

CALL 过程调用 

RET/RETF过程返回. 



#### 条件转移

`CMP`：隐含减法，相等时CF为1

JA/JNBE 不小于或不等于时转移. 
JAE/JNB 大于或等于转移. 
JB/JNAE 小于转移. 
JBE/JNA 小于或等于转移. 
以上四条,测试无符号整数运算的结果(标志CF和ZF). 
JG/JNLE 大于转移. 
JGE/JNL 大于或等于转移. 
JL/JNGE 小于转移. 
JLE/JNG 小于或等于转移. 



JE/JZ 等于转移. 
JNE/JNZ 不等于时转移. 
JC 有进位时转移. 
JNC 无进位时转移. 
JNO 不溢出时转移. 
JNP/JPO 奇偶性为奇数时转移. 
JP/JPE 奇偶性为偶数时转移. 
JS 符号位为 "1" 时转移. 



#### 循环控制指令(短转移) 

LOOP CX不为零时循环. 
LOOPE/LOOPZ CX不为零且标志Z=1时循环. 
LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. 
JCXZ CX为零时转移. 




### 处理器控制：

CLC 清进位标志位. 
STD  置方向标志位1     si，di递减
CLD  清方向标志位 为0  si，di递增



### 伪指令：

define 定义一个标识符来表示变量

DW 定义字(2字节)

PROC 定义过程. 
ENDP 过程结束. 
SEGMENT 定义段. 
ASSUME 建立段寄存器寻址. 
ENDS 段结束 
END 程序结束

OFFECT：



## 程序

### 以二进制输出：

左移，最高位到cf，输出cf





### 以十进制输出：



### 以十六进制输出：



### 字符串反序拷贝：



### 求和：



### 判断回文



### 字符串复制





### 扫描数组中的每个数值并累加到正数



### 小写转大写



### 奇偶数个数



### 判断是否为素数



### 使用冒泡排序





### 打印helloworld



### 输入十进制按十进制输出





### 求最大公约数
